/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.fhir.codegen

import com.google.fhir.codegen.primitives.FhirPathType
import com.google.fhir.codegen.schema.Element
import com.google.fhir.codegen.schema.Type
import com.google.fhir.codegen.schema.capitalized
import com.google.fhir.codegen.schema.elementIdToTypeNameMap
import com.google.fhir.codegen.schema.getBindingValueSetUrl
import com.google.fhir.codegen.schema.getContentReferenceType
import com.google.fhir.codegen.schema.getElementName
import com.google.fhir.codegen.schema.isBackboneElement
import com.google.fhir.codegen.schema.isCommonBinding
import com.google.fhir.codegen.schema.normalizeEnumName
import com.google.fhir.codegen.schema.typeIsEnumeratedCode
import com.google.fhir.codegen.schema.valueset.ValueSet
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.asTypeName

/** Represents a property representing a data element in the generated class. */
internal data class PropertyInfo(
  val name: String,
  val typeName: TypeName,
  val defaultValue: String?,
)

/**
 * Maps an [Element] to a [PropertyInfo] or a list of [PropertyInfo]s within the [MappingContext].
 *
 * This class centralizes the logic to determine the property's name, type, and default value.
 */
internal class PropertyMapper(
  val mappingContext: MappingContext,
  val modelClassName: ClassName,
  val valueSetMap: Map<String, ValueSet>,
) {
  enum class MappingContext {
    MODEL,
    BUILDER,
    SURROGATE,
  }

  /** Returns a [PropertyInfo] for the model or builder class. */
  fun mapToProperty(element: Element): PropertyInfo {
    check(mappingContext == MappingContext.MODEL || mappingContext == MappingContext.BUILDER)
    return PropertyInfo(element.getElementName(), getTypeName(element), getDefaultValue(element))
  }

  /**
   * Returns [PropertyInfo]s for the surrogate class.
   *
   * Use this method for data members in the surrogate class generated by
   * [SurrogateFileSpecGenerator] (e.g. `PatientSurrogate`). For the data class generated by
   * [ModelFileSpecGenerator] (e.g. `Patient`), use [getClassName].
   *
   * Elements of primitive data types in FHIR are mapped to two JSON properties:
   * - a JSON property that has the name of the element and a JSON type that represents the
   *   primitive value of the FHIR data type
   * - a JSON property that has a prefix '_' in the name and type `Element` containing the "id"
   *   and/or "extensions", if present.
   */
  fun mapToProperties(element: Element): List<PropertyInfo> {
    check(mappingContext == MappingContext.SURROGATE)
    if (element.isBackboneElement()) {
        modelClassName
          .nestedClass(element.id.substringAfterLast('.').capitalized())
          .withCardinalityInSurrogate(element)
      } else {
        element
          .getContentReferenceType(modelClassName.packageName)
          ?.withCardinalityInSurrogate(element)
      }
      ?.let {
        return listOf(
          PropertyInfo(element.getElementName(), it, getDefaultValueInSurrogate(element))
        )
      }

    // Otherwise, handle each type and combine the results
    return element.type!!.flatMap {
      val propertyName =
        if (element.type.size == 1) {
          element.getElementName()
        } else {
          "${element.getElementName()}${it.code.capitalized()}"
        }
      val baseType = mapTypeToClassName(it)
      if (FhirPathType.containsFhirTypeCode(it.code)) {
        listOf(
          PropertyInfo(
            propertyName,
            baseType
              // Make sure the primitive type is nullable in a list as it's always possible for the
              // list to contain null values for padding. See
              // https://www.hl7.org/fhir/R5/json.html#primitive.
              .copy(nullable = true)
              .withCardinalityInSurrogate(element)
              // The primitive element in the surrogate class should always be nullable, since it is
              // possible to omit this field entirely if the primitive has only id and/or extensions
              // in the companion element but no value. See
              // https://www.hl7.org/fhir/R5/json.html#primitive.
              .copy(nullable = true),
            // The default value for primitive types should always be `null` for the same reason.
            "null",
          ),
          PropertyInfo(
            "_$propertyName",
            ClassName(modelClassName.packageName, "Element")
              // Make sure the primitive type is nullable in a list as it's always possible for the
              // list
              // to contain null values for padding. See
              // https://www.hl7.org/fhir/R5/json.html#primitive.
              .copy(nullable = true)
              .withCardinalityInSurrogate(element)
              // The companion element (prefixed with an underscore) in the surrogate class should
              // always be nullable, since it is possible to omit this field entirely in JSON if the
              // primitive has no id and/or extensions.
              .copy(nullable = true),
            // The default value for the companion element of primitive types should always be
            // `null` for the same reason.
            "null",
          ),
        )
      } else {
        listOf(
          PropertyInfo(
            propertyName,
            baseType.withCardinalityInSurrogate(element),
            getDefaultValueInSurrogate(element),
          )
        )
      }
    }
  }

  /**
   * Determines the Kotlin class name for the `type` in the [Element].
   *
   * This does not consider the **content reference**, **choice of types**, **cardinality**, or
   * **BackboneElement**, which are characteristics of the entire [Element].
   *
   * This function is used to generate code for sealed interfaces and should be used sparingly. For
   * mapping properties, [mapToProperty] should be used.
   */
  fun mapTypeToClassName(type: Type): ClassName {
    if (
      type.extension
        ?.find { it.url == "http://hl7.org/fhir/StructureDefinition/structuredefinition-fhir-type" }
        ?.valueUrl == "integer64"
    ) {
      // Special case: see
      // https://chat.fhir.org/#narrow/channel/179266-fhirpath/topic/Integer64.20and.20Long
      // https://jira.hl7.org/browse/FHIR-46522
      return Long::class.asTypeName()
    }

    if (FhirPathType.containsFhirTypeCode(type.code)) {
      // A FHIR primitive data type, e.g., string.
      // N.B. the FHIR primitive data type here is different from the FHIRPath type. E.g., a name
      // can be a FHIR string type, and inside the FHIR string type there will be a `value` field
      // with the FHIRPath type "http://hl7.org/fhirpath/System.String".
      return when (mappingContext) {
        MappingContext.MODEL,
        MappingContext.BUILDER ->
          nestBuilderClass(ClassName(modelClassName.packageName, type.code.capitalized()))
        MappingContext.SURROGATE ->
          FhirPathType.getFromFhirTypeCode(type.code)!!.typeInSurrogateClass
      }
    }

    if (FhirPathType.Companion.getUris().contains(type.code)) {
      // Type for the 'value' field in FHIR primitive data type.
      // For example, the FHIR primitive data type string has a 'value' field with FHIRPath type
      // "http://hl7.org/fhirpath/System.String". The Kotlin type for this field is a Kotlin String.
      return FhirPathType.Companion.getFromUri(type.code)!!.getTypeInModelClass(
        modelClassName.packageName
      )
    }

    // An external complex type, e.g., `HumanName`.
    return nestBuilderClass(ClassName(modelClassName.packageName, type.code.capitalized()))
  }

  /**
   * Determines the Kotlin type name for the entire [com.google.fhir.codegen.schema.Element] in the
   * generated Kotlin class, considering:
   * - **Content Reference:** If the element has a `contentReference`, this is used to resolve the
   *   actual type.
   * - **Choice of Types:** For elements with a choice of types (e.g., `value[ x ]`), a sealed
   *   interface is generated to represent the different types. **Backbone Elements:** Backbone
   *   elements are represented as nested classes.
   * - **Enumeration:** Value sets are generated as enum classes.
   * - **FHIR Type:** The base FHIR data type of the element (e.g., string, integer,
   *   CodeableConcept).
   * - **Cardinality:** The element's cardinality (e.g., 0..1, 1..*, 0..*) determines whether the
   *   Kotlin type is nullable (e.g., `String?`) or a collection type (e.g., `List<String>`).
   */
  private fun getTypeName(element: Element): TypeName {
    return (getContentReferenceType(element)
        ?: getTypeOverride(element)
        ?: getSealedInterfaceType(element)
        ?: getBackboneElementType(element)
        ?: getEnumType(element)
        ?: mapTypeToClassName(element.type!!.single()))
      .applyCardinality(element)
  }

  /**
   * Gets the default value for a [ParameterSpec] based on the [Element].
   * - Elements with max cardinality "*" should default to a list in model class or a mutable list
   *   in builder class
   * - Elements with min cardinality "0" should default to null
   */
  private fun getDefaultValue(element: Element): String? {
    if (element.min != 0) {
      // Mandatory fields should not have default values
      return null
    }
    if (element.max == "*" || element.id == "xhtml.extension") {
      // The extension field of XHTML needs to be a list despite the cardinality of 0..0.
      return when (mappingContext) {
        MappingContext.MODEL -> "listOf()"
        MappingContext.BUILDER -> "mutableListOf()"
        else -> error("")
      }
    }
    return "null"
  }

  /** Returns the default value for the generated field in the surrogate class. */
  private fun getDefaultValueInSurrogate(element: Element): String? {
    if (element.max == "*" || element.min == 0) {
      // Whilst the default value for repeated elements is empty list in the model class, it is null
      // in the surrogate class. This is because the JSON object might omit the list altogether.
      return "null"
    }
    if ((element.type?.size ?: 0) > 1) {
      // Choice of types should always be nullable since there is no guarantee that any of the
      // choices
      // is the provided type in the surrogate class, and therefore should always have the default
      // value `null`.
      return "null"
    }
    return null
  }

  /**
   * Returns the [TypeName] for the [element] if it is an enumeration. This will be the
   * `Enumeration` class with the enum class as the type parameter e.g.,
   * `Enumeration<AdministrativeGender>`.
   *
   * Returns `null`, if the [element] is not an enumeration.
   */
  private fun getEnumType(element: Element): TypeName? {
    if (!element.typeIsEnumeratedCode(valueSetMap)) {
      return null
    }

    val elementBasePath = element.base?.path
    // Use the ValueSet.name for the enum class, subclasses re-use enums from the parent
    val valueSetName =
      valueSetMap.getValue(element.getBindingValueSetUrl()!!).name.normalizeEnumName()
    val enumClassName =
      if (element.path == elementBasePath) {
        valueSetName
      } else {
        // In rare cases, refer to the base enum, e.g., Distance.comparator and Quantity.comparator
        "${elementBasePath?.substringBefore(".") ?: ""}.$valueSetName"
      }
    val enumClassPackageName =
      when {
        element.isCommonBinding -> modelClassName.packageName + ".terminologies"
        enumClassName.contains(".") -> modelClassName.packageName
        else -> ""
      }
    val enumClass = ClassName(enumClassPackageName, enumClassName)
    return ClassName(modelClassName.packageName, "Enumeration").parameterizedBy(enumClass)
  }

  /**
   * Returns the [TypeName] for the [element] if it is a content reference. Otherwise, returns
   * `null`.
   *
   * The content reference should always be a backbone element.
   */
  private fun getContentReferenceType(element: Element): TypeName? {
    return element.getContentReferenceType(modelClassName.packageName)?.let {
      return nestBuilderClass(it)
    }
  }

  /**
   * Returns the [TypeName] for the [element] if it is a hardcoded type. Otherwise, returns `null`.
   *
   * This is used to handle the special case in R4 where `positiveInt` and `unsignedInt` have the
   * underlying type String.
   */
  private fun getTypeOverride(element: Element): TypeName? {
    return elementIdToTypeNameMap[element.id]?.let {
      return it.asTypeName()
    }
  }

  /**
   * Returns the [TypeName] for the [element] if it is a sealed interface. Otherwise, returns
   * `null`.
   */
  private fun getSealedInterfaceType(element: Element): TypeName? {
    // Sealed interfaces for choice types. E.g., element `Patient.deceased[x]` can have type
    // boolean or dateTime. The generated sealed interface `Deceased` nested under `Patient`
    // class has two subclasses `Boolean` and `DateTime`.
    // See https://www.hl7.org/fhir/r4/formats.html#choice (R4).
    if (element.type!!.size > 1) {
      // The only case where the choice type inherits from the base definition is the element
      // `MetadataResource.versionAlgorithm[x]`. In the case, for simplicity, the base type
      // `CanonicalResource.versionAlgorithm[x]` is used.
      if (element.id != element.base!!.path) {
        return ClassName(
          modelClassName.packageName,
          element.base.path.removeSuffix("[x]").split('.').map { it.capitalized() },
        )
      }
      return modelClassName.nestedClass(element.getElementName().capitalized())
    }
    return null
  }

  /**
   * Returns the [TypeName] for the [element] if it is a backbone element. Otherwise, returns
   * `null`.
   */
  private fun getBackboneElementType(element: Element): TypeName? {
    // Backbone element types are nested under the enclosing class e.g. `Patient.Contact`.
    if (element.isBackboneElement()) {
      return nestBuilderClass(
        modelClassName.nestedClass(element.id.substringAfterLast('.').capitalized())
      )
    }
    return null
  }

  /**
   * Transforms the [TypeName] depending on the [Element]'s cardinality.
   * - If the [Element]'s max cardinality is "*" or it is the extension element, make the type a
   *   list or mutable list.
   * - Otherwise, if the [Element]'s min cardinality is 0, make the type nullable.
   * - Otherwise, do nothing.
   */
  private fun TypeName.applyCardinality(element: Element): TypeName {
    return if (element.max == "*" || element.id == "xhtml.extension") {
      // The extension field of XHTML needs to be a list despite the cardinality of 0..0.
      ClassName(
          "kotlin.collections",
          if (mappingContext == MappingContext.BUILDER) {
            "MutableList"
          } else {
            "List"
          },
        )
        .parameterizedBy(this)
    } else if (element.min == 0) {
      this.copy(nullable = true)
    } else {
      this
    }
  }

  /**
   * Transforms the [TypeName] for model class depending on the [Element]'s cardinality.
   * - If the [Element]'s max cardinality is "*" or it is the extension element, make the type a
   *   list.
   * - Otherwise, if the [Element]'s min cardinality is 0, make the type nullable.
   * - Otherwise, do nothing.
   */
  private fun TypeName.withCardinalityInSurrogate(element: Element): TypeName {
    return if (element.max == "*" || element.id == "xhtml.extension") {
      // The extension field of XHTML needs to be a list despite the cardinality of 0..0.
      ClassName("kotlin.collections", "List").parameterizedBy(this).copy(nullable = true)
    } else if (element.min == 0) {
      this.copy(nullable = true)
    } else if (element.type != null && element.type.size > 1) {
      // Choice types should always be nullable since there is no guarantee that any of the
      // choices will be the provided type.
      this.copy(nullable = true)
    } else {
      this
    }
  }

  /**
   * Returns a nested `Builder` class if the [mappingContext] is [MappingContext.BUILDER].
   * Otherwise, returns the `className` itself.
   */
  private fun nestBuilderClass(className: ClassName): ClassName =
    when (mappingContext) {
      MappingContext.BUILDER -> className.nestedClass("Builder")
      else -> className
    }
}
